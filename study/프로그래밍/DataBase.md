
# 🗒DataBase

#공부 #DB #DataBase

---

# 프로시저란?
- 간단히 설명하면 "여러 쿼리를 한번에 실행하는 것" 이다.
- SQL의 Function과 비슷해 보이지만 차이가 있다.
	function : 클라이언트에서 처리, 리턴값 필수, 리턴값은 한개만 반환 가능
	프로시저 : 서버로 보내서 처리, 리턴값 선택, 리컨값 여러개 가능

속도면에서는 함수에 비해 프로시저가 더 빠르다.
그렇기 때문에 프로시저같은 경우는 실행,처리를 할때 주로 사용하고, 함수는 간단한 계산이나 수치 결과를 나타낼 때 사용한다.
### 프로시저를 사용하는 이유
1. 하나의 요청으로 여러 SQL문을 실행 할 수 있음
2. 네트워크 소요 시간을 줄일 수 있음(여러개의 쿼리를 처리하는 시점에서 네트워크  부하를 줄임)
3. 보수성이 뛰어나다
4. 개발 업무를 구분하여 개발할 수 있다.(DB관련 처리를 API처럼 만들어 사용가능)
### 프로시저의 단점
1. 재사용성이 낮다(DB버전 별 구문/규칙과 호환성이 다르기 때문)
2. 처리 성능이 좋지 않다(MySQL스토어드 프로그램 처리 성능이 낮다)

![[Pasted image 20240610171904.png]]

- 파라미터 선언은 프로시저명() 안에서 선언하고, SQL문과 변수는 BEGIN - END 안에서 작성한다.
- SELECT사용시 반드시, 조회한 컬럼의 값을 INTO로 변수 안에 넣어주어야 한다.
- 프로시저안에서 사용하는 SQL문은 세미콜론(;)으로 문장 끝을 맺어주어야 한다.
- if, case, loop 문을 사용할 수 있다.
- 프로시저내에서 다른 프로시저를 호출 할 수 있다.

---

# DB Connection이란 무엇일까?

	- 커넥션이란 어플리케이션과 데이터베이스 서버간의 통신 링크를 뜻한다.
		애플리케이션이 쿼리를 실행하고, 데이터를 검색하고, 데이터베이스에서 트랜젝션을 수행 할 수 있는 세션을
	설정하는데 사용된다.
	말그대로 애플리케이션과 DB를 연결하는 통신링크이며, 이가 모여있는것을 커넥션 풀 이라고 한다.
	매번 연결하고 끊고 하는것 보다 커넥션풀에 등록하는 것이 성능적인 향상을 기대할 수 있기 때문이다.


---

# DataBase 정규화  과정

## 정규화란?
 - 테이블 간에 중복된 데이터를 허용하지 않는다는 기본 목표를 갖는다.	
 - 중복된 데이터를 허용하지 않음으로 써 **무결성** 을 유지할 수 있다.

 ## 장점 
- DB의 저장 용량 또한 줄일 수 있다.
- 데이터 테이블을 분해하여 이상현상이 발생할 가능성을 줄이고, 확장/수정시 구조 변경을
 최소화 할 수 있다.
## 단점
- 릴레이션의 분해로 인해 Join연산이 늘어날 수 있다.
- 쿼리시 응답시간이 느려질 수 있다.

 *데이터의 중복속성을 최대한 제거하는 것 이기때문에, 속성이 하나의 테이블에 집약되므로
데이터 용량이 최소화 되어 상황에따라 처리속도가 빨라질 수도 있고, 느려질 수도 있다.*
*만약 조인이 만연하여 속도저하가 발생하게 된다면 반정규화를 통해 속도를 개선할 수 있다.*

### 제 1 정규화
- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
- 각 컬럼의 순서가 상관이 없어야한다.
- 하나의 컬럼은 같은 종류의 타입을 가져야 한다.
![[Pasted image 20240531103441.png]]
원자값을 갖도록 컬럼을 나눈다.
![[Pasted image 20240531103549.png]]


### 제 2 정규화
 - 제 1 정규화를 진행한 테이블에 대해 "완전 함수 종속"을 만족하도록 테이블을 분해하는 것이다.
- 여기서 완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다. 
  즉, 부분적 종속을 없애는 것이다.

![[Pasted image 20240531105228.png]]
해당 테이블의 기본키는 (학생번호, 강좌이름)으로 복합키 이다. 
성적은 (학생번호, 강좌이름)인 기본키가 결정하지만, 
강의실은 기본키의 부분집합인 강좌이름이 결정하게 된다.

즉, 부분집합이 결정자가 되지 않도록 테이블을 분리시키는 것으로 완전 함수 종속을 만족시킬 수 있다.
![[Pasted image 20240531105241.png]]

### 제3 정규화
- 제2 정규화를 진행한 테이블에 대해 "이행적 종속"을 없애도록 테이블을 분해하는 것이다.
- 여기서 이행적 종속이란 A -> B   , B -> C  가 성립할때, A -> C 가 성립되는 것을 의미한다.
![[Pasted image 20240531104351.png]]
다음의 경유 이행적 종속상태 로 말할 수 있다.

그 경우 테이블을 분리하여 데이터 변경시에 다른 데이터까지 변경되는 상황을 막을 수 있다.
![[Pasted image 20240531104418.png]]


### BCNF 정규화
- 제3 정규화를 좀 더 강화한 것이라 생각하면 된다.
- BCNF정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록
 테이블을 분해하는 것을 말한다.

![[Pasted image 20240531104751.png]]
특수 수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다.
또한, 여기서 교수는 특강이름을 결정하고있다.

문제는 교수가 특강이름을 결정하는 결정자 이지만, 후보키가 아니다.
그렇기 때문에 BCNF 정규화를 만족시키기 위해서는 테이블을 분해하여 아래와 같이 분리할 수 있다.

![[Pasted image 20240531104803.png]]



### 제4 정규화는 다치 종속을 없애는것이다
- 컬럼값의 중복을 제거하는것이다.
### 제5 정규화는 조인 종속을 없애는것이다.
- 중복을 제거하기 위해 분해할 수 있을만큼 최대한 분해하는 것이다.

#### 보통 정규화는 BCNF정규화 까지만 진행하는 경우가 많다.
	 그 이상 정규화를 진행하면 오히려 정규화의 단점이 더 커지기 때문이다.

---

# Dual 테이블이란??

## 오라클 자체에서 제공되는 테이블
## 간단하게 함수를 이용해서 계산결과값을 확인할 때 사용하는 테이블
### 오직 한 행, 한 컬럼 만을 담고 있는 Dummy 테이블이다.

---

# Lock ( 데이터베이스 락 ) 이란?
## 세션1이 트렌젝션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데,
세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.
이런문제를 방지하기 위해, 세션이 트렌젝션을 시작하고 데이터를 수정하는 동안에 커밋이나 롤백 전까지
다른세션에서 해당 데이터를 수정할 수 없게 막아야 한다. 이런 문제를 해결하기 위해 DB에서는
==LOCK 락== 이라는 개념을 제공한다.

- 락은 언제 사용하는가? : 트렌젝션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
- 일반적인 조회는 락을 사용하지 않는다.
- 락 타임아웃(다른 세션이 데이터를 점유하고 있을때 대기시간이 초과된 경우)에는 익셉션이 발생하게 된다.

---
# 엘라스틱서치 인덱스와 샤드 분할
*인덱스 : 단일데이터 단위인 도큐먼트(document)를 모아놓은 집합을 인덱스(index)라고 한다.*
*색인 : 데이터를 Elasticsearch에 저장하는 행위*
*샤드 : 인덱스는 기본적으로 샤드(shard)라는 단위로 분리되고, 각 노드에 분산되어 저장된다* (검색의 기본단위는 샤드이다.)
![[Pasted image 20240828104032.png]]
* 데이터를 범위나 카테고리로 나누어 관리하는 기법을 파티셔닝 이라고 한다.

## 프라이머리 샤드와 복제본(Replica)

- 인덱스를 생성할 때, 처음 생성된 샤드를 ==프라이머리 샤드==, 복제본은 ==리플리카== 라고 부른다.
- 예를 들어 한 인덱스가 5개의 샤드로 구성되어있고, 클러스터가 4개의 노드로 구성되어있다고 가정하면,
각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분산되어 저장된다.
![[Pasted image 20240828104728.png]]
*노드가 1개만 존재한다면 복제본은 생성되지 않는다. Elasticsearch는 아무리 작은 클러스터라도 최소 3개의 노드로 구성할 것을 권장하고 있다.*

- 이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실되어도 데이터를 잃어버리지 않고, 데이터 가용성과 무결성을 보장하게 된다.

### 검색시 샤드와 인덱스
	샤드는 여러 서버에 분산되어 병렬 및 병행으로 검색되므로, 인덱스가 같던 다르던 상관이 없다.
	검색의 기본 단위는 샤드이기 때문이다. 따라서 인덱스를 나누는 것은 운영의 편의성을 고려할 때 선택하는 방법이다.

### 색인시 인덱스
	전체색인을 할 경우 인덱스 1개가 7억건 이라면 색인이 모두 끝날때 까지 몇시간이 걸리게 된다.
	그 와중에 데이터에 변경이 있게 된다면 전체 색인 후 일괄적용이 들어가게 될텐데, 대기시간이 길어질 수록 일괄적용 시간도 함께 늘어나게 된다.
	결국 더 빠른 색인을 위해서는 하나의 인덱스를 여러개로 나누너 병행처리를 시키도록 해야한다.

	다나와 에서는 상품DB특성상 카테고리군 별로 인덱스를 나누고 있다. 
	이때의 장점은 특정 카테고리만 검색할때 해당 인덱스만 검색하면 되므로, 검색 속도가 현저히 감소하게 된다.

## 결론
- 일반적인 시스템 로그와 같은 로그성 문서는 색인을 하고 나면 수정이 필요없는 정적 컨텐츠인 반면
상품문서같은 경우 색인이 끝나도 계속 갱신되어야 하는 살아있는 동적 컨텐츠이다. 따라서 동적색인에 원할하고, 검색성능도 높은 설계를 요구한다.

---

# 트렌젝션 / DB스냅샷 / 앤티티매니저 / 영속성컨텍스트 / JPA

## 각각의 정의
트렌젝션
	- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

트렌젝션매니저
	- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.

@Transactional
	- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.

앤티티매니저
	- 영속성 컨텍스트를 관리하는 인터페이스
	- 엔티티의 저장/수정/삭제/조회 작업을 수행
	- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용
	- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능

영속성컨텍스트
	- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간
	- 엔티티와 DB데이터간의 상태 동기화를 책임
	- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다
	- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다

스냅샷
	- DB스냅샷 : 
		- 트렌젝션이 시작될때 생성된다.
		- 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.
		- 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.
		- 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.
	- 앤티티매니저_스냅샷 : 
		- 엔티티가 영속성 컨텍스트에 로드될 때 생성된다.
		- 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.